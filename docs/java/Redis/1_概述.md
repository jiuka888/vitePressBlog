# Redis 概述

Redis 是速度非常快的**非关系型（NoSQL）**基于**内存**的**键值**数据库。

键的类型只能为字符串，值可以支持五种数据类型：字符串（stirng）、列表（list）、集合(set)、散列表(hash)、有序集合(zset)。

Redis 支持很多特性，例如将内存中的数据持久化到硬盘中，使用复制来扩展**读性能**，使用分片来扩展**写性能**。

Redis 除了做缓存之外，也经常用来做分布式锁，甚至是消息队列。

## Redis & Memcached

分布式缓存主要解决的是单机缓存的容量受服务器限制并且无法保存通用信息的问题。

分布式缓存兴起时，比较常用的是 Memcached。随着 Redis 的发展，大家慢慢都转而使用更加强大的 Redis 了。现在基本没有看过还有项目使用 Memcached 来做缓存了。

两者相同点：

- 都是基于内存的非关系型内存键值数据库，一般都用来当做缓存使用。
- 都有过期策略
- 性能都非常高

主要有以下不同：

- 数据类型：

  Memcached 仅支持字符串类型，而 Redis 支持五种不同的数据类型，可以更灵活地解决问题。

- 线程模型：

  Memcached 是多线程，非阻塞 IO 复用的网络模型，而 Redis 使用单线程的多路 IO 复用模型。

- 删除策略：

  Memcached 过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除。

- 数据持久化：

  Redis 支持两种持久化策略：RDB 快照和 AOF 日志，而 Memcached 不支持持久化。

- 分布式：

  Memcached 不支持分布式，只能通过在客户端使用一致性哈希来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点。

  Redis Cluster 实现了分布式的支持。

- 内存管理机制

  - 在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘，而 Memcached 的数据则会一直在内存中。
  - Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。

## 使用场景

### 计数器

可以对 String 进行自增自减运算，从而实现计数器功能。

Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。

### 缓存

将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。

### 查找表

例如 DNS 记录就很适合使用 Redis 进行存储。

查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。

### 分布式锁实现

在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。

可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。

### 其它业务场景

Bitmap 可以实现统计统计活跃用户等功能。

Set 可以实现交集、并集等操作，从而实现共同好友等功能。

ZSet 可以实现有序性操作，从而实现排行榜等功能。



## 使用 Redis 缓存的好处

**高性能**：

假如用户第一次访问数据库中的某些数据的话，这个过程是比较慢，毕竟是从硬盘中读取的。但如果用户访问的数据属于高频数据并且不会经常改变的话，那么我们就可以很放心地将该用户访问的数据存在缓存中。

可以保证用户下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。不过，要保持数据库和缓存中的数据的一致性。 如果数据库中的对应数据改变的之后，需要同步改变缓存中相应的数据。

**高并发**：

一般像 MySQL 这类的数据库的 QPS（Query Per Second，服务器每秒可以执行的查询次数）大概都在 1w 左右（4 核 8g） ，使用 Redis 缓存之后很容易达到 10 w+，甚至最高能达到 30 w+（单机 Redis 的情况，Redis 集群的话会更高）。

由此可见，直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库，也就提高了系统整体的并发。
